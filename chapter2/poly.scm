(load "test.scm")
(load "putget.scm")
(load "tag.scm")
(load "deploy.scm")

(define (apply-generic op . args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
          (apply proc (map contents args))
          (error "No method for these types -- APPLY-GENERIC" 
                 (list op type-tags args)))
      )
    )
  )
; scheme number package
(define (install-scheme-number-package)
  (define (tag x) (attach-tag 'scheme-number x))
  (put 'equ? '(scheme-number scheme-number) =)
  (put '=zero? '(scheme-number) zero?)
  (put 'raise '(scheme-number)
       (lambda (x) (make-rational x 1)))  
  (put 'add '(scheme-number scheme-number)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(scheme-number scheme-number)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(scheme-number scheme-number)
       (lambda (x y) (tag (* x y))))
  (put 'div '(scheme-number scheme-number)
       (lambda (x y) (tag (/ x y))))
  (put 'negate '(scheme-number) 
       (lambda (x) (tag (- x))))
  (put 'make 'scheme-number
       (lambda (x) (tag x)))  
  'done  
  )
(define (make-scheme-number n)
  ((get 'make 'scheme-number) n))

(define (install-polynomial-package)
  ; internal procedures
  
  ; representation of poly
  (define (make-poly variable term-list)
    (cons variable term-list)    
    )
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  (define (variable? exp)
    (symbol? exp))
  (define (same-variable? exp1 exp2)
    (and (variable? exp1) (variable? exp2) (eq? exp1 exp2)))
  
  ;representation of terms an term lists
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (add-terms (term-list p1) 
                              (term-list p2)))
        (error "Polys not in same var -- ADD-POLY" (list p1 p2))
        )
    )
  (define (sub-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (sub-terms (term-list p1) 
                              (term-list p2)))
        (error "Polys not in same var -- SUB-POLY" (list p1 p2))
        )
    )
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1)
                   (mul-terms (term-list p1) 
                              (term-list p2)))
        (error "Polys not in same var -- MUL-POLY" (list p1 p2))
        )
    )
  
  ;interface to rest of the system
  (define (tag p) (attach-tag 'polynomial p))
  (put 'add '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'sub '(polynomial polynomial)
       (lambda (p1 p2) (tag (add-poly p1 (contents (negate (tag p2)))))))
  (put 'mul'(polynomial polynomial)
       (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'negate '(polynomial)
       (lambda (p) (tag (make-poly (variable p)
                                   (negate-terms (term-list p))))))  
  (put 'make 'polynomial
       (lambda (var terms) (tag (make-poly var terms))))
  'done
  )
(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))

(define (adjoin-term term term-list)
  (if (zero? (coeff term))
      term-list
      (cons term term-list)
      ))
(define (the-empty-termlist) '())
(define (empty-termlist? L) (null? L))
(define (first-term L) (car L))
(define (rest-terms L) (cdr L))
(define (make-term order coeff) (list order coeff))
(define (order term) (car term))
(define (coeff term) (cadr term))

(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) 
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term t1 (add-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term t2 (add-terms L1 (rest-terms L2))))
                 (else (adjoin-term (make-term (order t1) (add (coeff t1) (coeff t2)))
                                    (add-terms (rest-terms L1) (rest-terms L2))
                                    ))
                 )
           )
         )
        )
  )
(define (sub-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
        ((empty-termlist? L2) L1)
        (else
         (let ((t1 (first-term L1)) 
               (t2 (first-term L2)))
           (cond ((> (order t1) (order t2))
                  (adjoin-term t1 (sub-terms (rest-terms L1) L2)))
                 ((< (order t1) (order t2))
                  (adjoin-term t2 (sub-terms L1 (rest-terms L2))))
                 (else (adjoin-term (make-term (order t1) (sub (coeff t1) (coeff t2)))
                                    (sub-terms (rest-terms L1) (rest-terms L2))
                                    ))
                 )
           )
         )
        )
  )
  

(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
      (the-empty-termlist)
      (add-terms (mul-term-by-all-terms (first-term L1) L2) 
                 (mul-terms (rest-terms L1) L2))
      )
  )
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L) 
      (the-empty-termlist)
      (let ((t2 (first L)))
        (adjoin-term (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2))) 
                     (mul-term-by-all-terms t1 (rest-terms L)))
        )
      )
  )

(define (negate-terms l)
  (map (lambda (t) (make-term (order t) (- (coeff t)))) l)
  )

(define (add x1 x2)
  (apply-generic 'add x1 x2))

(define (sub x1 x2)
  (apply-generic 'sub x1 x2))

(define (mul x1 x2)
  (apply-generic 'mul x1 x2))

(define (negate x)
  (apply-generic 'negate x))

(install-scheme-number-package)
(install-polynomial-package)



(deploy global-array)
(define (test)
  (define t1 (make-term 2 1))
  (define t2 (make-term 3 2))
  (define t3 (make-term 2 2))
  (define x1 (make-polynomial 'x (list t1)))
  (define x2 (make-polynomial 'x (list t3)))
  (define y1 (make-polynomial 'y (list t2 t1)))
  (define y2 (make-polynomial 'y (list t1)))
  
  (testing (list t1 
                 x1
                 x2
                 (add x1 x2)
                 (mul x1 x2)
                 (sub x1 x2)
                 y1 y2
                 (add y1 y2)
                 (mul y1 y2)
                 (sub y1 y2)
                 
            )) 
  )


