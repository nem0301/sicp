(load "test.scm")
(define nil '())
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right)
  )

(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((< x (entry set)) (element-of-set? x (left-branch set)))
        ((> x (entry set)) (element-of-set? x (right-branch set)))
        )
  )

(define (adjoin-set x set)
  (cond ((null? set) (make-tree x nil nil))
        ((= x (entry set)) set)
        ((< x (entry set)) 
         (make-tree (entry set) 
                    (adjoin-set x (left-branch set)) 
                    (right-branch set))
         )
        ((> x (entry set)) 
         (make-tree (entry set) 
                    (left-branch set)
                    (adjoin-set x (right-branch set)))
         )
        )
  )

(define (print tree)
  (list (print-tree tree)
        (print-tree-hirachical tree)
        )
  )

(define (print-tree tree)
  (cond ((and (null? (left-branch tree)) (null? (right-branch tree)))
         (list (entry tree))
         )
        ((null? (left-branch tree))
         (append (list (entry tree))       
                 (print-tree (right-branch tree)))                 
         )
        ((null? (right-branch tree))
         (append (print-tree (left-branch tree))
                 (list (entry tree)))
         )
        (else         
         (append (print-tree (left-branch tree))
                 (list (entry tree))         
                 (print-tree (right-branch tree)))         
         )
        )
  )  
(define (print-tree-hirachical tree)
  (cond ((and (null? (left-branch tree)) (null? (right-branch tree)))
         (entry tree)
         )
        ((null? (left-branch tree))
         (append (list (entry tree))       
                 (list (print-tree (right-branch tree))))                 
         )
        ((null? (right-branch tree))
         (append (list (print-tree (left-branch tree)))
                 (list (entry tree)))
         )
        (else         
         (append (list (print-tree (left-branch tree)))
                 (list (entry tree))         
                 (list (print-tree (right-branch tree))))         
         )
        )
  )  

(define a (make-tree 1 nil nil))
(define b (make-tree 4 nil nil))
(define c (make-tree 8 nil nil))
(define d (make-tree 10 nil nil))
(define x (make-tree 3 a b))
(define y (make-tree 9 c d))
(define z (make-tree 5 x y))

(define (test)
  (testing (list (print z)
                 (element-of-set? 10 z)
                 (element-of-set? 1 z)
                 (element-of-set? 4 z)
                 (element-of-set? 5 z)
                 (element-of-set? 9 z)
                 (element-of-set? 8 z)
                 (element-of-set? 7 z)
                 (print (adjoin-set 11 z))
                 (print (adjoin-set 2 z))
                 (print (adjoin-set 4 z))
                 (print (adjoin-set 5 z))
                 (print (adjoin-set -1 z))
            )
           )
  )