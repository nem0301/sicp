(load "list.scm")
(load "fib.scm")
(define (square x) (* x x))

(define (map proc l)
  (if (null? l)
      nil
      (cons (proc (car l)) (map proc (cdr l)))
      )
  )

(define (scale-list l factor)
  (map (lambda (x) (* x factor)) l)
  )

(define (square-list l)
  (map (lambda (x) (* x x)) l)
  )

(define (for-each proc l)
  (let ((l-cdr (cdr l)))
    (proc (car l))
    (if (not (null? l-cdr))
        (for-each proc l-cdr)
        true
        )
    )  
  )

(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor))
          )
        )
  )

(define (scale-tree-with-map tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree-with-map sub-tree factor)
             (* sub-tree factor)
             )
         )
       tree
       )  
  )

(define (square-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree)))
          )
        )
  )

(define (square-tree-with-map tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree-with-map sub-tree)
             (* sub-tree sub-tree)
             )
         )
       tree
       )
  )

(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)
             )
         )
       tree
       )
  )

(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest))
        )
      )
  )

(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))
               )
         )
        (else (filter predicate (cdr sequence)))
        )
  )

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence) 
          (accumulate op initial (cdr sequence)))
      )
  )

(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))
      )  
  )

(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree)) 
                      (enumerate-tree (cdr tree))))
        )
  )

(define (list-fib-square n)
  (accumulate cons
              nil
              (map square
                   (map fib (enumerate-interval 0 n))))  
  )

(define (product-of-square-of-odd-elements sequence)
  (accumulate * 
              1
              (map square
                   (filter odd? sequence)))
  )

(define (map2 p seq)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence)
  )

(define (append2 seq1 seq2)
  (accumulate cons seq2 seq1)
  )

(define (length2 sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence)
  )

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms)
                (+ (* x higher-terms) this-coeff) 
                )
              0 coefficient-sequence)
  )

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map
                                 (lambda (x) (car x))
                                 seqs))            
            (accumulate-n op init (map
                                   (lambda (x) (cdr x))
                                   seqs)))      
      )
  )

(define x (list 1 2 3 4))
(define y (list 5 6 7 8))

(define (test)
  (newline)
  (display x)
  (newline)
  (display (scale-list x 10))
  (newline)
  (display (square-list x))
  (newline)
  (display (for-each (lambda (x) (* x x)) x) )
  (newline)
  (display (scale-tree (list (list x y) (list x y)) 2))
  (newline)
  (display (scale-tree-with-map (list (list x y) (list x y)) 2))
  (newline)
  (display (square-tree (list (list x y) (list x y))))
  (newline)
  (display (square-tree-with-map (list (list x y) (list x y))))
  (newline)
  (display (tree-map (lambda (x) (* x x)) (list (list x y) (list x y))))
  (newline)
  (display (subsets (list 1 2 3)))
  (newline)
  (display (filter odd? (list 1 2 3 4 5 6 7 8 9)))
  (newline)
  (display (accumulate + 0 (list 2 3 4 1 23 4)))
  (newline)
  (display (enumerate-interval 7 10))
  (newline)
  (display (enumerate-tree (list (list x y) (list x y))))
  (newline)
  (display (list-fib-square 10))
  (newline)
  (display (product-of-square-of-odd-elements (list 1 2 3 4 5)))
  (newline)
  (display (map square (list 1 2 3 4 )))
  (newline)
  (display (append2 (list 1 2 3 4) (list 5 6 7 8))) 
  (newline)
  (display (length2 (list 1 2 3 4 5 6 7 8)))
  (newline)
  (display (horner-eval 2 (list 1 3 0 5 0 1)))
  (newline)
  (display (accumulate-n + 0 (list (list 1 2 3) (list 4 5 6)
                                   (list 7 8 9) (list 10 11 12))))
  )
