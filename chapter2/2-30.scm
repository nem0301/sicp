(load "list.scm")

(define (map proc l)
  (if (null? l)
      nil
      (cons (proc (car l)) (map proc (cdr l)))
      )
  )

(define (scale-list l factor)
  (map (lambda (x) (* x factor)) l)
  )

(define (square-list l)
  (map (lambda (x) (* x x)) l)
  )

(define (for-each proc l)
  (let ((l-cdr (cdr l)))
    (proc (car l))
    (if (not (null? l-cdr))
        (for-each proc l-cdr)
        true
        )
    )  
  )

(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor))
          )
        )
  )

(define (scale-tree-with-map tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree-with-map sub-tree factor)
             (* sub-tree factor)
             )
         )
       tree
       )  
  )

(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (* sub-tree sub-tree)
             )
         )
       tree
       )
  )

(define x (list 1 2 3 4))
(define y (list 5 6 7 8))

(define (test)
  (newline)
  (display x)
  (newline)
  (display (scale-list x 10))
  (newline)
  (display (square-list x))
  (newline)
  (display (for-each (lambda (x) (* x x)) x) )
  (newline)
  (display (scale-tree (list (list x y) (list x y)) 2))
  (newline)
  (display (scale-tree-with-map (list (list x y) (list x y)) 2))
  (newline)
  (display (square-tree (list (list x y) (list x y))))
  )
